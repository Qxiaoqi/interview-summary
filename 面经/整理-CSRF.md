# CSRF (XSS的衍生)
一般攻击者会使用钓鱼网站或者邮件，引导用户进入第三方网站。然后在这个第三方网站中，给被攻击的网站发送请求

然后条件是：

1、用户已登录网站

2、且验证基于cookie

原理：
攻击者构造特殊url，用户登陆后cookie记录下服务端传回的session，然后再次向该网站发起请求的时候，会自动携带cookie，然后验证通过，进行相应破坏。


防范措施：

1、检测（Refer请求头）

阻止外域请求

但是refer可以人工修改，所以这个方案还存在一些问题，一般多用于图片防盗链。而且方案也不合适，如果正常用户通过第三方网站的链接GET进入的话，就不能阻止了。

2、 验证码

一些重要操作上，强制让用户进行交互，这样就能解决。但是验证码对用户来讲比较麻烦，只能在适当的情况下采用。

3、 SameSite

Set-Cookie响应头新增Samesite属性，Strict 和 Lax
* Strict表明该Cookie在任何情况下都不可能作为第三方Cookie
* Lax放宽限制，GET请求则，Cookie可以作为第三方Cookie（比如已经登陆淘宝，然后从第三网站跳到淘宝，这个时候可以不用重复登陆）

```js
Set-Cookie: foo=1; Samesite=Strict
```

# 4、Token

CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。

要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。

token由服务端生成的，可以加载请求头里，如果没有被获取到，是没办法请求成功的。如果被获取到了，那就相当于发生了XSS，已不属于CSRF。

多页应用：get请求的话可以将token加在url后面，post加在字段最后

单页应用：可以统一加在header里（看vue-router实现），然后存到localStorage里，还能保存用户的登陆状态
